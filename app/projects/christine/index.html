<!DOCTYPE html>
<html>

	<head>

		<meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no" />

		<meta name="apple-mobile-web-app-capable" content="yes" />

		<title><<< Christine >>></title>

		<script type="text/javascript" src="assets/js/socket.io.js"></script>
		<script type="text/javascript" src="assets/js/jquery.js"></script>

		<script type="text/javascript">

			var sigCanvas = null,
				context,
				socket = io();

			$(document).ready(function () {

				sigCanvas = document.getElementById("canvasSignature");

				initialize();

				window.addEventListener('resize', resizeCanvas, false);
				window.addEventListener('orientationchange', resizeCanvas, false);

				resizeCanvas();

				setTimeout(function () {
					socket.emit('load.img');
				},1000);
			});

			function resizeCanvas() {

				sigCanvas.width = window.innerWidth;
				sigCanvas.height = window.innerHeight;

			}

			window.save = function () {

				socket.emit('save.img', sigCanvas.toDataURL());

			}

			// works out the X, Y position of the click inside the canvas from the X, Y position on the page
			function getPosition(mouseEvent, sigCanvas) {
			 var x, y;
			 if (mouseEvent.pageX != undefined && mouseEvent.pageY != undefined) {
			    x = mouseEvent.pageX;
			    y = mouseEvent.pageY;
			 } else {
			    x = mouseEvent.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
			    y = mouseEvent.clientY + document.body.scrollTop + document.documentElement.scrollTop;
			 }

			 return { X: x - sigCanvas.offsetLeft, Y: y - sigCanvas.offsetTop };
			}

			socket.on('move.to', function (coords) {

				context.beginPath();
				context.strokeStyle = '#659b41';
				context.moveTo(coords.x, coords.y);
				context.closePath();

			});

			socket.on('load.img', function (imgSrc) {

				var img = new Image;
				img.onload = function(){
				  context.drawImage(img,0,0); // Or at whatever offset you like
				};
				img.src = imgSrc;

			});

			socket.on('line.to', function (coords) {

				context.strokeStyle = '#659b41';
				context.lineTo(coords.x, coords.y);
				context.stroke();

			});

			function initialize() {
			 // get references to the canvas element as well as the 2D drawing context
			
			 context = sigCanvas.getContext("2d");

			 // This will be defined on a TOUCH device such as iPad or Android, etc.
			 var is_touch_device = 'ontouchstart' in document.documentElement;

			 if (is_touch_device) {
			    // create a drawer which tracks touch movements
			    var drawer = {
			       isDrawing: false,
			       touchstart: function (coors) {
			          context.beginPath();
			          context.moveTo(coors.x, coors.y);
			          socket.emit('move.to', coors);
			          this.isDrawing = true;
			       },
			       touchmove: function (coors) {
			          if (this.isDrawing) {
			             context.lineTo(coors.x, coors.y);
			             socket.emit('line.to', coors);
			             context.stroke();
			          }
			       },
			       touchend: function (coors) {
			          if (this.isDrawing) {
			             this.touchmove(coors);
			             this.isDrawing = false;
			             window.save();
			          }
			       }
			    };

			    // create a function to pass touch events and coordinates to drawer
			    function draw(event) {

			       // get the touch coordinates.  Using the first touch in case of multi-touch
			       var coors = {
			          x: event.targetTouches[0].pageX,
			          y: event.targetTouches[0].pageY
			       };

			       context.strokeStyle = '#659b41';

			       // Now we need to get the offset of the canvas location
			       var obj = sigCanvas;

			       if (obj.offsetParent) {
			          // Every time we find a new object, we add its offsetLeft and offsetTop to curleft and curtop.
			          do {
			             coors.x -= obj.offsetLeft;
			             coors.y -= obj.offsetTop;
			          }
					  // The while loop can be "while (obj = obj.offsetParent)" only, which does return null
					  // when null is passed back, but that creates a warning in some editors (i.e. VS2010).
			          while ((obj = obj.offsetParent) != null);
			       }

			       // pass the coordinates to the appropriate handler
			       drawer[event.type](coors);
			    }


			    // attach the touchstart, touchmove, touchend event listeners.
			    sigCanvas.addEventListener('touchstart', draw, false);
			    sigCanvas.addEventListener('touchmove', draw, false);
			    sigCanvas.addEventListener('touchend', draw, false);

			    // prevent elastic scrolling
			    sigCanvas.addEventListener('touchmove', function (event) {
			       event.preventDefault();
			    }, false); 
			 }
			 else {

			    // start drawing when the mousedown event fires, and attach handlers to
			    // draw a line to wherever the mouse moves to
			    $("#canvasSignature").mousedown(function (mouseEvent) {
			       var position = getPosition(mouseEvent, sigCanvas);
			       context.strokeStyle = '#659b41';
			       context.moveTo(position.X, position.Y);
					socket.emit('move.to', {
						x: position.X,
						y: position.Y
					});
			       context.beginPath();

			       // attach event handlers
			       $(this).mousemove(function (mouseEvent) {
			          drawLine(mouseEvent, sigCanvas, context);
			       }).mouseup(function (mouseEvent) {
			          finishDrawing(mouseEvent, sigCanvas, context);
			       }).mouseout(function (mouseEvent) {
			          finishDrawing(mouseEvent, sigCanvas, context);
			       });
			    });

			 }
			}

			// draws a line to the x and y coordinates of the mouse event inside
			// the specified element using the specified context
			function drawLine(mouseEvent, sigCanvas, context) {

			 var position = getPosition(mouseEvent, sigCanvas);
			 context.strokeStyle = '#659b41';
			 context.lineTo(position.X, position.Y);
			 socket.emit('line.to', {
			 	x: position.X,
			 	y: position.Y
			 });
			 context.stroke();
			}

			// draws a line from the last coordiantes in the path to the finishing
			// coordinates and unbind any event handlers which need to be preceded
			// by the mouse down event
			function finishDrawing(mouseEvent, sigCanvas, context) {
			 // draw the line to the finishing coordinates
			 drawLine(mouseEvent, sigCanvas, context);

			 window.save();
			 context.closePath();

			 // unbind any events which could draw
			 $(sigCanvas).unbind("mousemove")
			             .unbind("mouseup")
			             .unbind("mouseout");
			}

		</script>
		
	</head>

	<body>

	   <div id="canvasDiv">
	      <!-- It's bad practice (to me) to put your CSS here.  I'd recommend the use of a CSS file! -->
	      <canvas id="canvasSignature" width="500px" height="500px" style="border:2px solid #000000;"></canvas>
	   </div>

	</body>

</html>